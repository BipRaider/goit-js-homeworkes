'use strict';
// ------------------------------------task-1--------------------

console.log('task-1', users.reduce((accum, elem) => [ ...accum, elem.name ], []));

// Существует такое понятие как оценка эффективности алгоритмов.
// О-нотация называется. Так вот, задача программиста состоит в том чтобы выбрать алгоритм из множества имеющихся.
// О-нотация подсказывает какой это может быть алгоритм.

// Рассмотрим к примеру ваше решение и решение
users.map(({ name }) => name);

// В последнем случае будет линейній перебор массива.
// Т.е. с ростом длинны массива на n элементов время работы алгоритма тоже увеличиься на n
// Т.к. у нас всего один цикл с одим набором операций.

// Теперь рассмотрим
users.reduce((accum, elem) => [ ...accum, elem.name ], []);

// На каждом шаге цикла мы должны будем создавать новый массив и копировать туда элементы.
// Грубо - это цикл в цикле. Т.е. сложность с ростом числа элементов n будет расти как n * n

// Т.е. map при 100 элементах будет выполнен за 100 * 100 тактов процессора
// а reduce за 100 * 100 = 10 000 тактов процессора.

// Т.к. процессор работает на частоте около 1 000 000 000 000
// то мы не заметим разницы.
// Но при числе элементов
// более 100 000 разница будет заметна.

// Так что формально ответ верный. Пройдете ли вы собеседование с таким ответом? Вряд ли - вам посоветуют подучить О-нотацию

// https://techrocks.ru/2019/10/19/big-o-notation-simply-explained/

// https://medium.com/siliconwat/algorithms-in-javascript-b0bed68f4038

//Получить массив объектов пользователей по цвету глаз (поле eyeColor).
console.log('task-2', users.reduce((accum, elem) => [ ...accum, elem.eyeColor ], []));

// Что быстрее цикл и затем еще цикл, т.е. 2 * n или цикл в цикле, т.е. n * n

// На малых значениях n неизвестно, надо мерять. На больших быстрее 2 * n

// Т.е. filter().map() предпочтительнее одного reduce в данном случае
